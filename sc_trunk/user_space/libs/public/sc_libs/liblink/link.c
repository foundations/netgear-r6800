/*
 * Copyright (C) 2012  Sercomm Corporation
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <getopt.h>
#include <unistd.h>
#include <ctype.h>
#include "sc_if_stats.h"
#include "sc_namespace.h"
typedef u_int64_t u64;
typedef u_int32_t uint32;
typedef u_int16_t uint16;
typedef u_int8_t uchar;
#include "link.h"
#include "if_name.h"
#include "sc_debug.h"
#include "scmisc.h"
#include "sc_project_defines.h"
#include "adsl.h"
#include "nvram.h"
#include "nvram_var.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#define __u32 unsigned 
#if defined(SC_CPU_MT7621) || defined(SC_CPU_MT7623)
#include "ra_ioctl.h"
#endif

#ifdef MTK_BSP
#define SC_IOCTL_READ_PORT_STATUS        		  (SIOCDEVPRIVATE + 0xA)
#define SC_IOCTL_READ_PORT_STATS	              (SIOCDEVPRIVATE + 0xB)
#else
#define SC_IOCTL_READ_PORT_STATUS        		  (SIOCDEVPRIVATE + 0x1)
#define SC_IOCTL_READ_PORT_STATS	              (SIOCDEVPRIVATE + 0x2)
#endif

#ifdef BCM_BSP
#define SIOCGLINKSTATE          (SIOCDEVPRIVATE + 1)
#define SIOCMIBINFO          (SIOCDEVPRIVATE + 3)
#endif

#if defined(RTL_BSP) || defined(MTK_BSP)
struct lan_port_status {
    unsigned char link;
    unsigned char speed;
    unsigned char duplex;
    unsigned char nway;
};

#elif defined(BCM_BSP)

#define SPEED_10MBIT        10000000
#define SPEED_100MBIT       100000000
#define SPEED_1000MBIT      1000000000

typedef struct lan_port_status
{
    unsigned long link;//mib ulIfLastChange actually;
    unsigned long speed;
    unsigned long duplex;
} IOCTL_MIB_INFO, *PIOCTL_MIB_INFO;
#endif

struct port_statistics  {
	unsigned int  rx_bytes;
 	unsigned int  rx_unipkts;
       unsigned int  rx_mulpkts;
	unsigned int  rx_bropkts;
 	unsigned int  rx_discard;
       unsigned int  rx_error;
	unsigned int  tx_bytes;
 	unsigned int  tx_unipkts;
       unsigned int  tx_mulpkts;
	unsigned int  tx_bropkts;
 	unsigned int  tx_discard;
       unsigned int  tx_error;
};

struct sc_filter_entry {
    char *name;
    u_int16_t vid;
    u_int16_t pid;
    u_int16_t pid2;
};

/* this list is auto generated by 'dongle_monitor -l' command. */
static struct sc_filter_entry dongle_list[] = {
    {"ZTE-MF637U", 0x19d2, 0x2000, 0x0031},
    {"ZTE-MF637", 0x19d2, 0x2000, 0x0031},
    {"ZTE-MF626", 0x19d2, 0x2000, 0x0031},
    {"ZTE-MF622", 0x19d2, 0x2000, 0x0001},
    {"VODAFONE-K3565-Z", 0x19d2, 0x2000, 0x0063},
    {"OVATION-MC950D", 0x1410, 0x5010, 0x4400},
    {"SIERRA-880U", 0x1199, 0x0fff, 0x6855},
    {"SIERRA-881U", 0x1199, 0x0fff, 0x6856},
    {"SIERRA-C597", 0x1199, 0x0fff, 0x0023},
    {"HUAWEI-E180", 0x12d1, 0x1001, 0x1001},
    {"HUAWEI-E220", 0x12d1, 0x1003, 0x1003},
    {"MOVISTAR-E226", 0x12d1, 0x1003, 0x1003},
    {"HUAWEI-E160", 0x12d1, 0x1003, 0x1003},
    {"HUAWEI-E160G", 0x12d1, 0x1003, 0x1003},
    {"HUAWEI-E1690", 0x12d1, 0x1446, 0x1001},
    {"HUAWEI-E261", 0x12d1, 0x1446, 0x140c},
    {"HUAWEI-E353s", 0x12d1, 0x14fe, 0x1506},
    {"HUAWEI-E156G", 0x12d1, 0x1003, 0x1003},
    {"HUAWEI-E1550", 0x12d1, 0x1446, 0x1001},
    {"HUAWEI-EC122", 0x12d1, 0x1505, 0x140c},
    {"HUAWEI-EC189", 0x12d1, 0x1505, 0x140c},
    {"HUAWEI-EC1270",0x12d1, 0x1446, 0x140c},
    {"HUAWEI-E392",0x12d1, 0x1505, 0x1506},    
    {"YOTA-LU150",0x1076, 0x8001, 0x8002},    
    {"YOTA-LU150",0x1076, 0x8001, 0x8003},    
    {"YOTA-WLTUBA107",0x15a9, 0x002a, 0x002a},   
    {"YOTA-WLTUBA1071",0x216f, 0x0043, 0x0043},   
    {"ITON_CBP71", 0x15eb, 0x7153, 0x7152},
    {"ITON_BU580", 0x05c6, 0x6000, 0x6000},
     {"ITON_BU580", 0x05c6, 0x1000, 0x6000},
    {"T-MOBILE-E170", 0x12d1, 0x1003, 0x1003},
    {"Orange-iCON_7_2", 0x0af0, 0x1000, 0x6901},
    {"VERIZON_USB720", 0x1410, 0x2110, 0x2110},
    {"VODAFONE-K3520", 0x12d1, 0x1001, 0x1001},
    {"VODAFONE-K3565", 0x12d1, 0x1003, 0x1003},
    {"VODAFONE-E172", 0x12d1, 0x1003, 0x1003},
    {"VODAFONE-E272", 0x12d1, 0x1003, 0x1003},
    {"O2-GI0431", 0x0af0, 0x7501, 0x7501},
    {"ORANGE-GI0225", 0x0af0, 0x6971, 0x6971},
    {"OPTION-GI0201", 0x0af0, 0x6911, 0x6911},
    {"OPTION-GI0401", 0x0af0, 0x7401, 0x7401},
    {"DM9601", 0x0fe6, 0x8101, 0x8101},
    {NULL, 0, 0}
};

static int myPipe2(char *command, char **output)
{
  FILE *fp;
  char buf[4096];
  int len=0;

  *output=malloc(1);
  strcpy(*output, "");
  if((fp=popen(command, "r"))==NULL)
     return(-1);
  while((fgets(buf, 4096, fp)) != NULL){
     len=strlen(*output)+strlen(buf);
     if((*output=realloc(*output, (sizeof(char) * (len+1))))==NULL)
     return(-1);
      strcat(*output, buf);
  }
  pclose(fp);
  return len;
}
/* Check dongle whether supporte by router. If the driver included in dongle list, 
 * we treat this dongle as available,then router is allowed to change to 3G/4G mode.
 * 0 is unavailable, 1 is available.  */

int is_available_dongle_pluged()
{
	struct sc_filter_entry *entry;
	char *usbdev_info = NULL;
	unsigned int vendor, productID;
	int ret = 0, isKey = 0;

	myPipe2("/bin/cat /proc/bus/usb/devices", &usbdev_info);
	if (usbdev_info)
	{
		char *p = NULL, *p1 = NULL;
		if((p = strstr(usbdev_info, "Vendor=")) != NULL)
		{
			if(strncmp(p, "Vendor=1d6b", strlen("Vendor=1d6b")) != 0)
				isKey = 1;
			else
				p1 = p+6;
			if(!isKey && (p = strstr(p1, "Vendor=")) != NULL)
			{
				if(strncmp(p, "Vendor=1d6b", strlen("Vendor=1d6b")) != 0)
					isKey = 1;
				else
					p1 = p+6;
				if(!isKey)
				{
					if((p = strstr(p1, "Vendor=")) != NULL)
						isKey = 1;
				}
			}
		}
		if(isKey && p != NULL){
			sscanf(p, "Vendor=%04x ProdID=%04x Rev=", &vendor, &productID);
			SC_CFPRINTF("Faileover Debug : dongle vendor:%04x, productID:%04x\n", vendor, productID);
			for (entry = &dongle_list[0]; entry->name; entry++) {
				if(entry->vid == vendor && (entry->pid == productID || entry->pid2 == productID))
					ret = 1;
			}
		}
		else
			SC_CFPRINTF("No available dongle!\n");
		free(usbdev_info);
	}
	return ret;
}

#if defined(SC_CPU_MT7621) || defined(SC_CPU_MT7623)
#ifdef SC_SWITCH_USE_GMAC2
int rt3052_esw_reg_read(int offset, int *value)
{
	int esw_fd;
	struct ifreq ifr;
	esw_reg reg;

	if (value == NULL)
		return -1;

	esw_fd = socket(AF_INET, SOCK_DGRAM, 0);
	if (esw_fd < 0) {
		perror("socket");
		exit(0);
	}
	reg.off = offset;
	strncpy(ifr.ifr_name, "eth2", 5);
	ifr.ifr_data = &reg;
	if (-1 == ioctl(esw_fd, RAETH_ESW_REG_READ, &ifr)) {
		perror("ioctl");
		close(esw_fd);
		exit(0);
	}
	*value = reg.val;

	close(esw_fd);

	return 0;
}
#endif

static int mtk7621_switch_reg_read(int offset, int *value)
{
	if (value)
	{
		int esw_fd;
		struct ifreq ifr;
		ra_mii_ioctl_data mii;

		esw_fd = socket(AF_INET, SOCK_DGRAM, 0);
		if (esw_fd < 0) {
			SC_CFPRINTF("socket error\n");
			return -1;
		}
		strncpy(ifr.ifr_name, "eth2", 5);
		ifr.ifr_data = &mii;
	
		mii.phy_id = 0x1f;
		mii.reg_num = offset;
	
		if (-1 == ioctl(esw_fd, RAETH_MII_READ, &ifr)) {
			SC_CFPRINTF("ioctl error\n");
			close(esw_fd);
			return 0;
		}
		*value = mii.val_out;
		close(esw_fd);
	}
	return 0;
}
#endif

#ifdef BCM_BSP
int get_bcm_ether_wan_port(int portnum,struct lan_port_status *port_status)
{
    char name[10] = "eth0";
    char buf [128] = {0};
    char *data = NULL;
    
    if(portnum != 4)
        return -1;
     
    sprintf(buf, "/usr/sbin/ethctl %s media-type ", name);
    myPipe2(buf, &data);
    if(data)
    {
        if(strstr(data, "Link is up"))
        { 
            port_status->link = 1;
            /* Get speed */          
            if(strstr(data, "1000"))
                port_status->speed = SPEED_1000MBIT;
            else if(strstr(data, "100"))
                port_status->speed = SPEED_100MBIT;
            else
                port_status->speed = SPEED_10MBIT;
            /* ether port mode: full or half duplex */
            if(strstr(data, "FD") || strstr(data, "Full Duplex"))
                port_status->duplex = 1;
            else
                port_status->duplex = 0;
        }
        else
            port_status->link = 0; 
                                         
        free(data); 
    } 
    
    return 0;    
}
#endif

/*  */
static int get_lanport_stats(int portnum, struct port_statistics *port_stats)
{
#if 1//def SC_CPU_MT7621
	FILE *fp;
	char buf[512];
	int readit = 0;
	unsigned int fake;
	
	fp = fopen("/proc/net/dev", "r");
	if (!fp) {
		SC_CFPRINTF("can't open proc net dev\n");
		return -1;
	}
	fgets(buf, sizeof buf, fp);	/* eat line */
	fgets(buf, sizeof buf, fp);

	while (fgets(buf, sizeof buf, fp)) {
		if (portnum==WAN_PORT_INDEX)
		{
			if (strstr(buf, WAN_PHY_IFNAME))	
			{
				SC_CFPRINTF("readit\n");
				readit = 1;	
			}
		} else
		{
			if (strstr(buf, LAN_PHY_IFNAME))	
			{
				SC_CFPRINTF("readit\n");
				readit = 1;
			}				
		}
		if (readit)
		{
			char *p = strchr(buf, ':');
			if (p)
			{
				sscanf(p+1, "%u %u %u %u %u %u %u %u %u %u %u %u %u %u",
		                &port_stats->rx_bytes, &port_stats->rx_unipkts, &fake, &fake,
		                &fake, &fake, &fake, &fake,
		                &port_stats->tx_bytes, &port_stats->tx_unipkts, &fake, &fake, &fake, &port_stats->tx_error);
	            }
			break;
		}
	}
	fclose(fp);
	return 0;
#else
     struct ifreq ifr;
     int sockfd;
     char *name = SYS_ETH_IFNAME;
     unsigned int *args;

     if(portnum > 5)
        return -1;

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
            printf("fatal error socket\n");
            return -3;
       }
    args = (unsigned int *)port_stats;
    ((unsigned int *)(&ifr.ifr_data))[0] =(unsigned int)port_stats;
    *args = portnum;

    strcpy((char*)&ifr.ifr_name, name);

    if (ioctl(sockfd, SC_IOCTL_READ_PORT_STATS, &ifr)<0)
    {
            printf("device ioctl:");
            close(sockfd);
            return -1;
     }
     close(sockfd);
#endif

    return 0;
}

static int get_lanport_status(int portnum,struct lan_port_status *port_status)
{
#if defined(SC_CPU_MT7621) || defined(SC_CPU_MT7623)

	int offset = 0, reg_val = 0;
	
	offset = 0x3008;
	switch(portnum)
	{
		case 0:
			offset = 0x3008;
			break;
		case 1:
			offset = 0x3108;
			break;
		case 2:
			offset = 0x3208;
			break;
		case 3:
			offset = 0x3308;
			break;
		case 4:
			offset = 0x3408;			
			break;
	}
#if defined (SC_SWITCH_USE_GMAC2) && defined (SDK_MTK4210)
	if(portnum == WAN_PORT_INDEX) {
		offset = 0x0208; //from raether.c
		rt3052_esw_reg_read(offset, &reg_val);
	} 
	else
#endif
	mtk7621_switch_reg_read(offset, &reg_val);
	SC_CFPRINTF("0x%x 0x%x\n", offset, reg_val);
	if (reg_val&0x1)
	{	
		port_status->link = 1;
		if (reg_val&0x2)
		{
			port_status->duplex = 1;
		} else
		{
			port_status->duplex = 0;
		}
		if (reg_val&0x8)
		{
			port_status->speed = 2;
		} else if (reg_val&0x4)
		{
			port_status->speed = 1;
		} else
		{
			port_status->speed = 0;	
		}		
	} else
	{
		port_status->link = 0;
	}	
#else	
    struct ifreq ifr;
     int sockfd;
#if defined(RTL_BSP) || defined(MTK_BSP)
     char *name = SYS_ETH_IFNAME;
#else
    char name[10] = "eth0";
#endif
     struct lan_port_status status;
#if defined(RTL_BSP) || defined(MTK_BSP)
     unsigned int *args;
#endif

     if(portnum > 5)
        return -1;
#ifdef BCM_BSP
    /* Ether net Wan use other function to get the port status */
    if(portnum == 4)
    {
        get_bcm_ether_wan_port(portnum, port_status);
        return 0;
    }
#endif
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
            printf("fatal error socket\n");
            return -3;
       }
#if defined(RTL_BSP) || defined(MTK_BSP)
    args = (unsigned int *)&status;
    ((unsigned int *)(&ifr.ifr_data))[0] =(unsigned int)&status;
    *args = portnum;
#else    
    sprintf(name, "eth%d",(portnum+1));
    ((unsigned int *)(&ifr.ifr_data))[0] =(unsigned int)&status;
#endif

    strcpy((char*)&ifr.ifr_name, name);

#if defined(RTL_BSP) || defined(MTK_BSP)
    if (ioctl(sockfd, SC_IOCTL_READ_PORT_STATUS, &ifr)<0)
#else
    if (ioctl(sockfd, SIOCMIBINFO, &ifr)<0)
#endif
    {
            printf("device ioctl:");
            close(sockfd);
             return -1;
     }
     close(sockfd);
     memcpy((char *)port_status,(char *)&status,sizeof(struct lan_port_status));
#endif

    return 0;

}
/*******************************************************************************
 * NAME: get_ports_link_status
 *
 * DESCRIPTION:
 *       get ALL ports status
 *
 * INPUTS:
 *
 * OUTPUTS:
 *       status --- All interfaces status including link/up_rate/down_rate...
 *
 * COMMENTS:
 *
 *******************************************************************************/
struct port_link_status_s *get_ports_link_status(void) {
    static struct port_link_status_s status[MAX_PHY_PORTS];
    int i;
    int ret;
    /* Set it to init value */
    for(i=0; i<MAX_PHY_PORTS; i++) {
        status[i].link = LINK_UP;
        status[i].duplex = DUPLEX_HALF;
        status[i].up_rate = PHY_RATE_10M;
        status[i].down_rate = PHY_RATE_10M;
    }

    /* Get Link speed & status*/
    for(i=0; i<MAX_PHY_PORTS; i++) {
        struct lan_port_status port_status;
        struct port_statistics port_stats;
        int rate = PHY_RATE_100M;
        if ((ret = get_lanport_status(PORT_SWAP(i), &port_status)) < 0)
        {
            SC_CFPRINTF("Get Link speed fail code: %d\n", ret);
            SC_CFPRINTF("Get Link duplex fail code: %d\n", ret);
            goto back;
        }
        status[i].link = port_status.link ? LINK_UP : LINK_DOWN;
#if defined(RTL_BSP) || defined(MTK_BSP)
        switch(port_status.speed)
        {
            case 1:
                rate = PHY_RATE_100M;
                break;
            case 2:
                rate = PHY_RATE_1000M;
                break;
            case 0:
                rate = PHY_RATE_10M;
                break;
        }
#else
        rate = port_status.speed;
#endif
        status[i].up_rate = status[i].down_rate = rate;
        /* Get Link duplex */
        status[i].duplex = port_status.duplex ? DUPLEX_FULL : DUPLEX_HALF;
        memset(&port_stats, 0, sizeof(port_stats));
        if ((ret = get_lanport_stats(PORT_SWAP(i), &port_stats)) < 0)
        {
            SC_CFPRINTF("get port %d stats failed\n", i);
            goto back;
        }
        status[i].txpkts = port_stats.tx_unipkts + port_stats.tx_mulpkts + port_stats.tx_bropkts;
        status[i].txbytes = port_stats.tx_bytes;
        status[i].rxpkts = port_stats.rx_unipkts + port_stats.rx_mulpkts + port_stats.rx_bropkts;
        status[i].rxbytes = port_stats.rx_bytes;
        status[i].collisions = port_stats.tx_error;
    }

back:
#ifdef _SC_DEBUG_ENABLE_
    SC_XCFPRINTF("\n");
    SC_XCFPRINTF("PORT#(L/WAN): %-6s%-6s%-8s%-10s%-10s%-10s%-10s%-10s\n",
        "LINK", "SPEED", "DUPLEX", "TXPKTS", "TXBYTES", "RXPKTS", "RXBYTES", "Collisions");
    for(i=0; i<MAX_PHY_PORTS; i++) {
        SC_XCFPRINTF("PORT%d (%s%c): %-6s%-6d%-8s%-10lu%-10lu%-10lu%-10lu%-10lu\n",
            i,
            i==WAN_PORT_INDEX?"WAN":"LAN",
            i==WAN_PORT_INDEX?' ':'1'+i,
            status[i].link == LINK_UP ? "UP": "DOWN",
            status[i].up_rate/(1000*1000) ,
            status[i].duplex == DUPLEX_FULL ? "FULL": "HALF",
            status[i].txpkts, status[i].txbytes, status[i].rxpkts, status[i].rxbytes, status[i].collisions);
    }
#endif /* _SC_DEBUG_ENABLE_ */
    return status;
}

/*port from cgi*/
int modem_status_cgi(cgi_adsl_info_t *adsl)
{
	char tmp[2048] = "";
	char *pt = NULL;
	char *pn = NULL;
	FILE *fp;

	/* ----- get firmware ------ */
	system("/usr/sbin/adslctl --version 2> /tmp/adsl-ver ");
	fp=fopen("/tmp/adsl-ver","r");
	if(fp==NULL)
		return -1;
	fread(tmp,2048,1,fp);
	fclose(fp);

	pt=strstr(tmp,"ADSL PHY:");

	if(pt==NULL){
		return -1;
	}
	sscanf(pt,"%*[^-]- %s",adsl->firmware);

	/* ------ get status -------*/
	system("/usr/sbin/adslctl info > /tmp/adsl-stats");
	fp=fopen("/tmp/adsl-stats","r");
	if(fp==NULL)
		return -1;

	fread(tmp,2048,1,fp);
	fclose(fp);
	if((pt=strstr(tmp,"Status:"))==NULL){
		return -1;
	}

	sscanf(pt,"%*[^:]: %s ",adsl->status);

	if(strcmp(adsl->status,"Showtime")!=0){//2006.11.22
		return 0;
	}

	system("/usr/sbin/adslctl info --stats > /tmp/adsl-stats");
	fp=fopen("/tmp/adsl-stats","r");
	if(!fp)
		return -1;
	fread(tmp,2048,1,fp);
	fclose(fp);

	/* get detial status */
	/* format like:Max:    Upstream rate = 1116 Kbps, Downstream rate = 25460 Kbps */
	if((pt=strstr(tmp,"Max:"))==NULL){
		return -1;
	}

    /*goto next lin:
    format like:Bearer: 0,   Upstream rate = 1116 Kbps, Downstream rate = 25460 Kbpse*/
	if((pt=strchr(pt+4,':'))==NULL){
		return -1;
	}
	if((pt=strchr(pt,'='))==NULL){
		return -1;
	}
	pt += 2;
	sscanf(pt, "%d", &adsl->up_stream);

	if((pt=strchr(pt,'='))==NULL){
		return -1;
	}
	pt += 2;
	sscanf(pt, "%d", &adsl->down_stream);

    if(*nvram_safe_get("wan_traffic_type") == 'p')
	{

        memset(tmp, 0, sizeof(tmp));
        system("/usr/sbin/adslctl info --pbParams > /tmp/adsl-pbParams");
    	fp=fopen("/tmp/adsl-pbParams","r");
    	if(!fp)
    		return -1;
    	fread(tmp,2048,1,fp);
    	fclose(fp);
        
        if((pt=strstr(tmp,"Line Attenuation(dB):"))==NULL){
    		return -1;
    	}
    	/* move the point to Up Line Attenuation vaule */
    	pt += strlen("Line Attenuation(dB):");
    	if((pt=strstr(pt,"U0"))==NULL){
    		return -1;
    	}
    	pn = strchr(pt, '\n');
    	memset(adsl->line_u_att, 0,sizeof(adsl->line_u_att));
    	strncpy(adsl->line_u_att, pt, (pn-pt-1));
    	/* move the point to Down Line Attenuation vaule */
    	if((pt=strstr(pt,"D0"))==NULL){
    		return -1;
    	}
    	pn = strchr(pt, '\n');
    	memset(adsl->line_d_att, 0,sizeof(adsl->line_d_att));
    	strncpy(adsl->line_d_att, pt, (pn-pt-1));
    	/* move the point to Up SNR Margin vaule */
    	if((pt=strstr(tmp,"SNR Margin(dB):"))==NULL){
    		return -1;
    	}
    	pt += strlen("SNR Margin(dB):");
    	if((pt=strstr(pt,"U0"))==NULL){
    		return -1;
    	}
    	pn = strchr(pt, '\n');
    	memset(adsl->u_margin, 0, sizeof(adsl->u_margin));
    	strncpy(adsl->u_margin, pt, (pn-pt-1));
    	/* move the point to Down SNR Margin vaule */
    	if((pt=strstr(pt,"D0"))==NULL){
    		return -1;
    	}
    	pn = strchr(pt, '\n');
    	memset(adsl->d_margin, 0, sizeof(adsl->d_margin));
    	strncpy(adsl->d_margin, pt, (pn-pt-1));
    }
    else
    {
        if((pt=strstr(tmp,"SNR (dB):"))==NULL){
		return -1;
    	}
    
    	sscanf(pt,"%*[^:]: %s %s",adsl->d_margin,adsl->u_margin);
    
    	if((pt=strstr(tmp,"Attn(dB):"))==NULL){
    		return -1;
    	}
    	sscanf(pt,"%*[^:]: %s %s",adsl->line_d_att,adsl->line_u_att); 
    }
	
	return 0;
}
/*******************************************************************************
 * NAME: get_wan_port_link_status
 *
 * DESCRIPTION:
 *       get wan port link status
 *
 * INPUTS:
 *
 * OUTPUTS:
 *       status --- the wan interface status including link/up_rate/down_rate
 *
 * COMMENTS:
 *
 *******************************************************************************/
struct port_link_status_s *get_wan_port_link_status(void) {
#ifdef ADSL
#ifdef DUAL_WAN
    struct port_link_status_s *p = NULL;
    cgi_adsl_info_t adsl ;
    static struct port_link_status_s p_status ;
    
    if(strcmp(nvram_safe_get(WAN_ACTYPE), L2_DSL) == 0)
    {
	    modem_status_cgi(&adsl);
	    p_status.link = (*adsl.status == 'S')?LINK_UP:LINK_DOWN;
	    p_status.up_rate = adsl.up_stream * 1000;
	    p_status.down_rate = adsl.down_stream * 1000;
	    return &p_status;    	
    }
    else
    {
    	p = get_ports_link_status();
    	return p+WAN_PORT_INDEX;
	}

#else
    cgi_adsl_info_t adsl ;
    static struct port_link_status_s p ;
    
    modem_status_cgi(&adsl);
    p.link = (*adsl.status == 'S')?LINK_UP:LINK_DOWN;
    p.up_rate = adsl.up_stream * 1000;
    p.down_rate = adsl.down_stream * 1000;
    return &p;
#endif
#else
	struct port_link_status_s *p = get_ports_link_status();
	return p+WAN_PORT_INDEX;
#endif
}

/*******************************************************************************
 * NAME: get_eth_wan_port_link_status
 *
 * DESCRIPTION:
 *       get wan port link status
 *
 * INPUTS:
 *
 * OUTPUTS:
 *       status --- the wan interface status including link/up_rate/down_rate
 *
 * COMMENTS:
 *
 *******************************************************************************/
struct port_link_status_s *get_eth_wan_port_link_status(void) {
    struct port_link_status_s *p = get_ports_link_status();
    return p+WAN_PORT_INDEX;
}

/*******************************************************************************
 * NAME: get_dsl_wan_port_link_status
 *
 * DESCRIPTION:
 *       get wan port link status
 *
 * INPUTS:
 *
 * OUTPUTS:
 *       status --- the wan interface status including link/up_rate/down_rate
 *
 * COMMENTS:
 *
 *******************************************************************************/
struct port_link_status_s *get_dsl_wan_port_link_status(void) {
    cgi_adsl_info_t adsl ;
    static struct port_link_status_s p ;
    
    modem_status_cgi(&adsl);
    p.link = (*adsl.status == 'S')?LINK_UP:LINK_DOWN;
    p.up_rate = adsl.up_stream * 1000;
    p.down_rate = adsl.down_stream * 1000;
    return &p;
}

/*******************************************************************************
 * NAME: reset_lan_switch
 *
 * DESCRIPTION:
 *       Pull-low LAN switch for 3 seconds then pull-high
 * INPUTS:
 *
 * OUTPUTS:
 *
 * COMMENTS:
 *          Still dont know why need to set bit 3 of phyaddr 1~4 reg 0x1E.
 *          Got this information from broadcom borg.
 *******************************************************************************/
#define PROC_PHY_POWER   "/proc/phyPower"
#define WAN_PORT_MASK    (0x10)
#define LAN_PORT_MASK    (0x0F)
#define COMMAND_BUF_SIZE (256)

void reset_lan_switch(void) {

	reset_lan_switch2(3);
	return;
}

void reset_lan_switch2(int sleeptime) {

#if defined(SC_CPU_MT7621) || defined(SC_CPU_MT7623)
	system("/etc/mtk/mt7621_switch_link.sh down 0");
	system("/etc/mtk/mt7621_switch_link.sh down 1");
	system("/etc/mtk/mt7621_switch_link.sh down 2");
	system("/etc/mtk/mt7621_switch_link.sh down 3");
	sleep(sleeptime);
	system("/etc/mtk/mt7621_switch_link.sh up 0");
	system("/etc/mtk/mt7621_switch_link.sh up 1");
	system("/etc/mtk/mt7621_switch_link.sh up 2");
	system("/etc/mtk/mt7621_switch_link.sh up 3");
#else
#ifdef RTL_BSP
    char cmdbuf[COMMAND_BUF_SIZE];
    snprintf(cmdbuf, sizeof(cmdbuf), "/bin/echo '%d 0' > %s", LAN_PORT_MASK, PROC_PHY_POWER);
    system(cmdbuf);
    sleep(sleeptime);

    snprintf(cmdbuf, sizeof(cmdbuf), "/bin/echo '%d 1' > %s", LAN_PORT_MASK, PROC_PHY_POWER);
    system(cmdbuf);

#else /* RTL_BSP */
#ifdef BCM_BSP
    int i;
    char cmdbuf[COMMAND_BUF_SIZE];
    for(i=0; i<MAX_PHY_PORTS; i++) {

//#ifdef EXTERNAL_SWITCH
#if 0
    if(i == WAN_PORT_INDEX)
            continue;
/* broadcom mdkshell command. */
#define MDKSHELL(__cmd)  do { \
	char buff[512]; \
    snprintf(buff, sizeof(buff), "/bin/echo \"%s\" >> /var/mdksh", __cmd); \
	system(buff); \
} while(0)
#define MDKSHELL_START() do { \
	system("/bin/rm -f /var/mdksh 2>/dev/null"); \
} while(0)
#define MDKSHELL_END() do { \
	int wait = 0;	\
	MDKSHELL("quit"); \
	system("/bin/echo SHELL > /var/mdkshell"); \
	while (access("/var/mdksh", F_OK) == 0 && ++wait < 10)	\
		sleep(1);	\
} while(0)

	MDKSHELL_START();
	MDKSHELL("1:");
    snprintf(cmdbuf, sizeof(cmdbuf), "phy %d 0 0 0x8000", i);
	MDKSHELL(cmdbuf);
    snprintf(cmdbuf, sizeof(cmdbuf), "seti reg 0x3600 0x3");
	MDKSHELL(cmdbuf);
    snprintf(cmdbuf, sizeof(cmdbuf), "seti reg 0x3610 1");
	MDKSHELL(cmdbuf);
	MDKSHELL_END();
#else
     /* Now D7000 eth0 is wan port */ 
    if(i == 0)
            continue;       
    snprintf(cmdbuf, sizeof(cmdbuf), "/usr/sbin/ethctl eth%d phy-power down", i);    
    system(cmdbuf);
    sleep(sleeptime);
    snprintf(cmdbuf, sizeof(cmdbuf), "/usr/sbin/ethctl eth%d phy-power up", i);    
    system(cmdbuf);
#endif
    }
#else /* BCM_BSP */
	char switch_on[64] = "";
	char switch_off[64] = "";
	int i,j;
	/* refresh LAN switch and get new IP address */
	for(i = 1; i < 5; i++)
	{	
		memset(switch_off, 0, sizeof(switch_off));
		sprintf(switch_off, "/bin/echo write.p 0x%d 0x0 0x0 0x800 > /proc/sw_ar8327" , i);
		system(switch_off);
	}
	sleep(sleeptime);
	for(j = 1; j < 5; j++)
	{	
		memset(switch_on, 0, sizeof(switch_on));
		sprintf(switch_on, "/bin/echo write.p 0x%d 0x0 0x0 0x3100 > /proc/sw_ar8327" , j);
		system(switch_on);
	}
#endif /* BCM_BSP */
#endif /* RTL_BSP */
#endif /* MTK_BSP */
	return;
}


void reset_lan_switch_DOWN() {

#if defined(SC_CPU_MT7621) || defined(SC_CPU_MT7623)
	system("/etc/mtk/mt7621_switch_link.sh down 0");
	system("/etc/mtk/mt7621_switch_link.sh down 1");
	system("/etc/mtk/mt7621_switch_link.sh down 2");
	system("/etc/mtk/mt7621_switch_link.sh down 3");
#else
#ifdef RTL_BSP
    char cmdbuf[COMMAND_BUF_SIZE];
    snprintf(cmdbuf, sizeof(cmdbuf), "/bin/echo '%d 0' > %s", LAN_PORT_MASK, PROC_PHY_POWER);
    system(cmdbuf);
#else /* RTL_BSP */
#ifdef BCM_BSP
    int i;
    char cmdbuf[COMMAND_BUF_SIZE];
    for(i=0; i<MAX_PHY_PORTS; i++) {

//#ifdef EXTERNAL_SWITCH
#if 0
#else
     /* Now D7000 eth0 is wan port */ 
    if(i == 0)
            continue;       
    snprintf(cmdbuf, sizeof(cmdbuf), "/usr/sbin/ethctl eth%d phy-power down", i);    
    system(cmdbuf);
#endif
    }
#else /* BCM_BSP */
	char switch_on[64] = "";
	char switch_off[64] = "";
	int i,j;
	/* refresh LAN switch and get new IP address */
	for(i = 1; i < 5; i++)
	{	
		memset(switch_off, 0, sizeof(switch_off));
		sprintf(switch_off, "/bin/echo write.p 0x%d 0x0 0x0 0x800 > /proc/sw_ar8327" , i);
		system(switch_off);
	}
#endif /* BCM_BSP */
#endif /* RTL_BSP */
#endif /* MTK_BSP */
	return;
}



void reset_lan_switch_UP() {

#if defined(SC_CPU_MT7621) || defined(SC_CPU_MT7623)
	system("/etc/mtk/mt7621_switch_link.sh up 0");
	system("/etc/mtk/mt7621_switch_link.sh up 1");
	system("/etc/mtk/mt7621_switch_link.sh up 2");
	system("/etc/mtk/mt7621_switch_link.sh up 3");
#else
#ifdef RTL_BSP
    char cmdbuf[COMMAND_BUF_SIZE];

    snprintf(cmdbuf, sizeof(cmdbuf), "/bin/echo '%d 1' > %s", LAN_PORT_MASK, PROC_PHY_POWER);
    system(cmdbuf);

#else /* RTL_BSP */
#ifdef BCM_BSP
    int i;
    char cmdbuf[COMMAND_BUF_SIZE];
    for(i=0; i<MAX_PHY_PORTS; i++) {

//#ifdef EXTERNAL_SWITCH
#if 0

#else
     /* Now D7000 eth0 is wan port */ 
    if(i == 0)
            continue;       
    snprintf(cmdbuf, sizeof(cmdbuf), "/usr/sbin/ethctl eth%d phy-power up", i);    
    system(cmdbuf);
#endif
    }
#else /* BCM_BSP */
	char switch_on[64] = "";
	char switch_off[64] = "";
	int i,j;

	for(j = 1; j < 5; j++)
	{	
		memset(switch_on, 0, sizeof(switch_on));
		sprintf(switch_on, "/bin/echo write.p 0x%d 0x0 0x0 0x3100 > /proc/sw_ar8327" , j);
		system(switch_on);
	}
#endif /* BCM_BSP */
#endif /* RTL_BSP */
#endif /* MTK_BSP */
	return;
}


void get_dev_fields(char *bp, struct interface *ife) 
{
    sscanf(bp,
	     "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu",
	     &ife->rx_bytes, &ife->rx_packets, &ife->rx_errors,
	     &ife->rx_dropped, &ife->rx_fifo_errors, &ife->rx_frame_errors,
	     &ife->rx_compressed, &ife->rx_multicast, &ife->tx_bytes,
	     &ife->tx_packets, &ife->tx_errors, &ife->tx_dropped,
	     &ife->tx_fifo_errors, &ife->collisions,
	     &ife->tx_carrier_errors, &ife->tx_compressed);
} 

char *get_name(char *name, char *p) 
{
    while (isspace(*p))
	p++;
    while (*p)
    {
	if (isspace(*p))
	    break;
	if (*p == ':')
	{			/* could be an alias */
	    char *dot = p, *dotname = name;
	    *name++ = *p++;
	    while (isdigit(*p))
		*name++ = *p++;
	    if (*p != ':')
	    {			/* it wasn't, backup */
		p = dot;
		name = dotname;
	    }
	    if (*p == '\0')
		return NULL;
	    p++;
	    break;
	}
	*name++ = *p++;
    }
    *name++ = '\0';
    return p;
}

void if_readlist_proc(struct interface *ife) 
{
    FILE * fh;
    char buf[256];
    fh = fopen(_PATH_PROCNET_DEV, "r");
    fgets(buf, sizeof(buf), fh);	/* eat line */
    fgets(buf, sizeof(buf), fh);
    while (fgets(buf, sizeof(buf), fh))
    {
	char *s;
	if (strstr(buf, ife->name))
	    
	{
	    s = get_name(ife->name, buf);
	    get_dev_fields(s, ife);
	}
    }
    fclose(fh);
}
