--- mlabel.c_OLD	2009-03-31 13:39:14.000000000 +0800
+++ mlabel.c	2009-03-31 13:39:14.000000000 +0800
@@ -83,11 +83,13 @@
 	long serial = 0;
 	int need_write_boot = 0;
 	int have_boot = 0;
-	char *eptr = "";
+	char *eptr;
 	struct bootsector boot;
 	Stream_t *Fs=0;
 	int r;
 	struct label_blk_t *labelBlock;
+	int isRo=0;
+	int *isRop=NULL;
 
 	init_clash_handling(&ch);
 	ch.name_converter = label_name;
@@ -136,21 +138,28 @@
 
 	init_mp(&mp);
 	newLabel = argv[optind]+2;
-	interactive = !show && !clear &&!newLabel[0] && 
-		(set_serial == SER_NONE);
-	open_mode = O_RDWR;
-	RootDir = open_root_dir(argv[optind][0], open_mode);
 	if(strlen(newLabel) > VBUFSIZE) {
 		fprintf(stderr, "Label too long\n");
 		FREE(&RootDir);
 		exit(1);
 	}
 
-	if(!RootDir && open_mode == O_RDWR && !clear && !newLabel[0] &&
-	   ( errno == EACCES || errno == EPERM) ) {
+	interactive = !show && !clear &&!newLabel[0] && 
+		(set_serial == SER_NONE);
+	if(!clear && !newLabel[0]) {
+		isRop = &isRo;
+	}
+
+	if (isRop == 0)
+		open_mode = O_RDWR ;
+	else
+		open_mode = isRo;
+
+//	RootDir = open_root_dir(argv[optind][0], isRop ? 0 : O_RDWR, isRop);
+	RootDir = open_root_dir(argv[optind][0], open_mode);
+	if(isRo) {
 		show = 1;
 		interactive = 0;
-		RootDir = open_root_dir(argv[optind][0], O_RDONLY);
 	}	    
 	if(!RootDir) {
 		fprintf(stderr, "%s: Cannot initialize drive\n", argv[0]);
